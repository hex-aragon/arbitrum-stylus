use alloc::string::String;
use alloc::vec::Vec;
use core::fmt::Write;
use stylus_sdk::alloy_primitives::FixedBytes;

use crate::base64::base64_encode;

const SVG_WIDTH: i32 = 1000;
const SVG_HEIGHT: i32 = 1000;
const BACKGROUND_COLOR: &str = "#1a1a1a";

const MIN_OSCILLATIONS: usize = 4;
const MAX_OSCILLATIONS: usize = 15;

const MIN_STROKE_WIDTH: usize = 10;
const MAX_STROKE_WIDTH: usize = 80;

const MIN_PERIOD: usize = 20;
const MAX_PERIOD: usize = 100;

const MIN_AMPLITUDE: usize = 100;
const MAX_AMPLITUDE: usize = 600;

pub struct SquiggleGenerator {
    seed: FixedBytes<32>,
}

struct SquiggleParameters {
    x_offsets: Vec<i32>,
    y_coordinates: Vec<i32>,
    stroke_width: i32,
    gradient_type: u8,
}

impl SquiggleGenerator {
    pub fn new(seed: FixedBytes<32>) -> Self {
        Self { seed }
    }

    // 컨트랙트에 의해 호출될 메인 함수
    // 1. SVG를 생성
    // 2. SVG를 Base64로 인코딩
    // 3. JSON 메타데이터를 생성
    // 4. 메타데이터를 Base64로 인코딩
    // 5. 적절한 접두사(data:application/json;base64,)와 함께 인코딩된 메타데이터를 문자열로 반환
    pub fn metadata(&self) -> String {
        let svg = self.svg();
        let base64_svg = base64_encode(&svg);

        let metadata = format!(
            r#"{{"name":"Stylus Squiggle","description":"A squiggle generated by Stylus","image":"data:image/svg+xml;base64,{}"}}"#,
            base64_svg
        );
        let base64_metadata = base64_encode(&metadata);

        let final_metadata = format!(r#"data:application/json;base64,{}"#, base64_metadata);
        final_metadata
    }

    // 실제 SVG 문자열 `<svg ... />`를 생성
    // 이것이 이미지 생성 로직입니다
    fn svg(&self) -> String {
        // SVG에 대한 무작위 매개변수를 생성
        // x_offsets, y_coordinates, stroke_width, gradient_type 포함
        let params = self.generate_parameters();
        let mut svg = String::new();

        // SVG 헤더 작성
        writeln!(svg, r#"<svg width='{}' height='{}' viewBox='0 0 {} {}' xmlns='http://www.w3.org/2000/svg'>"#, SVG_WIDTH, SVG_HEIGHT, SVG_WIDTH, SVG_HEIGHT).unwrap();
        writeln!(
            svg,
            r#"<rect width="100%" height="100%" fill="{}"/>"#,
            BACKGROUND_COLOR
        )
        .unwrap();

        // 모든 점을 연결하기 위한 SVG `path` 요소 생성
        let path_data = self.generate_oscillations_path(&params.x_offsets, &params.y_coordinates);
        writeln!(svg, r#"<path d="{}" stroke-width="{}" fill="none" stroke="url(#gradient)" stroke-linecap="round"/>"#, path_data, params.stroke_width).unwrap();

        // SVG용 그라디언트 생성
        let gradient = self.generate_gradient(params.gradient_type);
        writeln!(svg, r#"{}"#, gradient).unwrap();

        // SVG 태그 닫기
        writeln!(svg, r#"</svg>"#).unwrap();

        svg
    }

    // SVG에 대한 무작위 매개변수 생성
    fn generate_parameters(&self) -> SquiggleParameters {
        // 처음 세 바이트는 진동 수, 스트로크 너비, 그라디언트 타입을 계산하는 데 사용됨
        let num_oscillations = self.map_byte(self.seed[0], MIN_OSCILLATIONS, MAX_OSCILLATIONS);
        let stroke_width = self.map_byte(self.seed[1], MIN_STROKE_WIDTH, MAX_STROKE_WIDTH);
        let gradient_type = self.seed[2] % 3;

        // 다음 최대 15바이트는 각 진동의 X 오프셋을 계산하는 데 사용됨
        // 즉, 이전 진동의 X 좌표로부터의 오프셋
        let mut x_offsets = [0i32; MAX_OSCILLATIONS];
        for i in 0..num_oscillations as usize {
            let byte_idx = 3 + i as usize;
            let x_offset = self.map_byte(self.seed[byte_idx], MIN_PERIOD, MAX_PERIOD);
            x_offsets[i] = x_offset;
        }

        // 다음 최대 15바이트는 각 진동의 Y 좌표를 계산하는 데 사용됨
        // 즉, 진동이 얼마나 높거나 낮은지
        let mut y_coordinates = [0i32; MAX_OSCILLATIONS];
        for i in 0..num_oscillations as usize {
            let byte_idx = 17 + i;
            let y_coordinate = self.map_byte(self.seed[byte_idx], MIN_AMPLITUDE, MAX_AMPLITUDE);
            // 위아래 번갈아가기
            let sign = if i % 2 == 0 { -1 } else { 1 };
            y_coordinates[i] = sign * y_coordinate as i32;
        }

        SquiggleParameters {
            x_offsets: x_offsets[..num_oscillations as usize].to_vec(),
            y_coordinates: y_coordinates[..num_oscillations as usize].to_vec(),
            stroke_width,
            gradient_type,
        }
    }

    // 모든 점을 연결하기 위한 SVG `path` 요소 생성
    fn generate_oscillations_path(&self, x_offsets: &[i32], y_coordinates: &[i32]) -> String {
        let mut path = String::new();

        let total_oscillations_width: i32 = x_offsets.iter().sum();
        let center_y = SVG_HEIGHT / 2;
        let mut current_x = (SVG_WIDTH as i32 - total_oscillations_width) / 2;

        write!(path, "M {},{} ", current_x, center_y).unwrap();

        // 각 (x,y) 점 사이에 부드러운 곡선 생성
        for (&x_offset, &y_coordinate) in x_offsets.iter().zip(y_coordinates.iter()) {
            let next_x = current_x + x_offset;

            // 제어점 계산 - 정수 나눗셈 사용
            let cp1_x = current_x + (x_offset / 3);
            let cp1_y = center_y + y_coordinate;
            let cp2_x = current_x + (2 * x_offset / 3);
            let cp2_y = center_y + y_coordinate;

            // 3차 베지어 곡선
            write!(
                path,
                "C {},{} {}, {} {},{} ",
                cp1_x, cp1_y, cp2_x, cp2_y, next_x, center_y
            )
            .unwrap();

            current_x = next_x;
        }

        path
    }

    // SVG용 그라디언트 생성
    // gradient_type에 대해 선택된 값에 따라 3가지 옵션 중 선택
    fn generate_gradient(&self, gradient_type: u8) -> String {
        let mut gradient = String::new();
        let rainbow_gradient = [
            ("0.00", (255, 0, 0)),    // 빨강
            ("16.67", (255, 142, 0)), // 주황
            ("33.33", (255, 239, 0)), // 노랑
            ("50.00", (0, 241, 29)),  // 초록
            ("66.67", (0, 255, 255)), // 청록
            ("83.33", (0, 64, 255)),  // 파랑
            ("100.0", (128, 0, 255)), // 보라
        ];

        let sunset_gradient = [
            ("0.00", (255, 95, 109)),
            ("25.00", (255, 140, 105)),
            ("50.00", (255, 160, 122)),
            ("75.00", (255, 182, 193)),
            ("100.0", (255, 192, 203)),
        ];

        let ocean_gradient = [
            ("0.00", (30, 144, 255)),
            ("25.00", (0, 206, 209)),
            ("50.00", (32, 178, 170)),
            ("75.00", (72, 209, 204)),
            ("100.0", (0, 255, 255)),
        ];

        let gradient_data: &[(&str, (u8, u8, u8))] = match gradient_type {
            0 => &rainbow_gradient,
            1 => &sunset_gradient,
            2 => &ocean_gradient,
            _ => &rainbow_gradient,
        };

        writeln!(
            gradient,
            r#"<linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="0%">"#
        )
        .unwrap();
        for (offset, (r, g, b)) in gradient_data.iter() {
            writeln!(
                gradient,
                r#"<stop offset="{}%" stop-color="rgb({}, {}, {})"/>"#,
                offset, r, g, b
            )
            .unwrap();
        }
        writeln!(gradient, r#"</linearGradient>"#).unwrap();

        gradient
    }

    // 단일 바이트를 min과 max 사이의 숫자로 매핑
    fn map_byte(&self, byte: u8, min: usize, max: usize) -> i32 {
        (min + (byte as usize * (max - min) / 255)) as i32
    }
}

#[cfg(test)]
mod tests {
    use is_svg::is_svg;
    use std::{
        fs::{create_dir, File},
        io::Write,
        path::Path,
    };

    use super::*;

    #[test]
    fn test_svg_generation() {
        let seed = FixedBytes::<32>::random();
        let config = SquiggleGenerator::new(seed);
        let svg = config.svg();

        assert!(is_svg(svg));
    }

    #[test]
    fn test_output_100_svgs() {
        for i in 0..100 {
            let seed = FixedBytes::<32>::random();
            let config = SquiggleGenerator::new(seed);
            let svg = config.svg();
            assert!(is_svg(&svg));

            let dir = Path::new("test_output");
            if !dir.exists() {
                create_dir(dir).expect("Failed to create test output directory");
            }

            let file_name = format!("svg_{}.svg", i + 1);
            let file_path = Path::new(dir).join(file_name);
            let mut file = File::create(file_path).unwrap();
            file.write_all(svg.as_bytes()).unwrap();
        }
    }
}