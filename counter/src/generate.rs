use alloc::string::String;
use alloc::vec::Vec;
use core::fmt::Write;
use stylus_sdk::alloy_primitives::FixedBytes;

use crate::base64::base64_encode;

const SVG_WIDTH: i32 = 1000;
const SVG_HEIGHT: i32 = 1000;
const BACKGROUND_COLOR: &str = "#1a1a1a";

const MIN_OSCILLATIONS: usize = 4;
const MAX_OSCILLATIONS: usize = 15;

const MIN_STROKE_WIDTH: usize = 10;
const MAX_STROKE_WIDTH: usize = 80;

const MIN_PERIOD: usize = 20;
const MAX_PERIOD: usize = 100;

const MIN_AMPLITUDE: usize = 100;
const MAX_AMPLITUDE: usize = 600;

pub struct SquiggleGenerator {
    seed: FixedBytes<32>,
}

struct SquiggleParameters {
    x_offsets: Vec<i32>,
    y_coordinates: Vec<i32>,
    stroke_width: i32,
    gradient_type: u8,
}

impl SquiggleGenerator {
    pub fn new(seed: FixedBytes<32>) -> Self {
        Self { seed }
    }

    // Main function that will be called by the contract
    // 1. Generates the SVG
    // 2. Base64 encodes the SVG
    // 3. Generates the JSON metadata
    // 4. Base64 encodes the metadata
    // 5. Returns the encoded metadata as a string with the proper prefix (data:application/json;base64,)
    pub fn metadata(&self) -> String {
        let svg = self.svg();
        let base64_svg = base64_encode(&svg);

        let metadata = format!(
            r#"{{"name":"Stylus Squiggle","description":"A squiggle generated by Stylus","image":"data:image/svg+xml;base64,{}"}}"#,
            base64_svg
        );
        let base64_metadata = base64_encode(&metadata);

        let final_metadata = format!(r#"data:application/json;base64,{}"#, base64_metadata);
        final_metadata
    }

    // Generates the actual SVG string `<svg ... />`
    // This is the image generation logic
    fn svg(&self) -> String {
        // Generate the random parameters for the SVG
        // includes x_offsets, y_coordinates, stroke_width, and gradient_type
        let params = self.generate_parameters();
        let mut svg = String::new();

        // Write the SVG header
        writeln!(svg, r#"<svg width='{}' height='{}' viewBox='0 0 {} {}' xmlns='http://www.w3.org/2000/svg'>"#, SVG_WIDTH, SVG_HEIGHT, SVG_WIDTH, SVG_HEIGHT).unwrap();
        writeln!(
            svg,
            r#"<rect width="100%" height="100%" fill="{}"/>"#,
            BACKGROUND_COLOR
        )
        .unwrap();

        // Generate the SVG `path` element to connect all the points together
        let path_data = self.generate_oscillations_path(&params.x_offsets, &params.y_coordinates);
        writeln!(svg, r#"<path d="{}" stroke-width="{}" fill="none" stroke="url(#gradient)" stroke-linecap="round"/>"#, path_data, params.stroke_width).unwrap();

        // Generate the gradient for the SVG
        let gradient = self.generate_gradient(params.gradient_type);
        writeln!(svg, r#"{}"#, gradient).unwrap();

        // Close the SVG tag
        writeln!(svg, r#"</svg>"#).unwrap();

        svg
    }

    // Generates the random parameters for the SVG
    fn generate_parameters(&self) -> SquiggleParameters {
        // First three bytes are used to calculate number of oscillations, stroke width, and gradient type
        let num_oscillations = self.map_byte(self.seed[0], MIN_OSCILLATIONS, MAX_OSCILLATIONS);
        let stroke_width = self.map_byte(self.seed[1], MIN_STROKE_WIDTH, MAX_STROKE_WIDTH);
        let gradient_type = self.seed[2] % 3;

        // Upto next 15 bytes are used to calculate the X offset of each oscillation
        // i.e. the offset from the previous oscillation's X coordinate
        let mut x_offsets = [0i32; MAX_OSCILLATIONS];
        for i in 0..num_oscillations as usize {
            let byte_idx = 3 + i as usize;
            let x_offset = self.map_byte(self.seed[byte_idx], MIN_PERIOD, MAX_PERIOD);
            x_offsets[i] = x_offset;
        }

        // Upto next 15 bytes are used to calculate the Y coordinates of each oscillation
        // i.e. how high or low the oscillation is
        let mut y_coordinates = [0i32; MAX_OSCILLATIONS];
        for i in 0..num_oscillations as usize {
            let byte_idx = 17 + i;
            let y_coordinate = self.map_byte(self.seed[byte_idx], MIN_AMPLITUDE, MAX_AMPLITUDE);
            // alternate between going up and down
            let sign = if i % 2 == 0 { -1 } else { 1 };
            y_coordinates[i] = sign * y_coordinate as i32;
        }

        SquiggleParameters {
            x_offsets: x_offsets[..num_oscillations as usize].to_vec(),
            y_coordinates: y_coordinates[..num_oscillations as usize].to_vec(),
            stroke_width,
            gradient_type,
        }
    }

    // Generates the SVG `path` element to connect all the points together
    fn generate_oscillations_path(&self, x_offsets: &[i32], y_coordinates: &[i32]) -> String {
        let mut path = String::new();

        let total_oscillations_width: i32 = x_offsets.iter().sum();
        let center_y = SVG_HEIGHT / 2;
        let mut current_x = (SVG_WIDTH as i32 - total_oscillations_width) / 2;

        write!(path, "M {},{} ", current_x, center_y).unwrap();

        // create a smooth curve between each (x,y) point
        for (&x_offset, &y_coordinate) in x_offsets.iter().zip(y_coordinates.iter()) {
            let next_x = current_x + x_offset;

            // control points calculation - use integer division
            let cp1_x = current_x + (x_offset / 3);
            let cp1_y = center_y + y_coordinate;
            let cp2_x = current_x + (2 * x_offset / 3);
            let cp2_y = center_y + y_coordinate;

            // cubic bezier curve
            write!(
                path,
                "C {},{} {}, {} {},{} ",
                cp1_x, cp1_y, cp2_x, cp2_y, next_x, center_y
            )
            .unwrap();

            current_x = next_x;
        }

        path
    }

    // Generates the gradient for the SVG
    // Picks from 3 options based on what value was chosen for gradient_type
    fn generate_gradient(&self, gradient_type: u8) -> String {
        let mut gradient = String::new();
        let rainbow_gradient = [
            ("0.00", (255, 0, 0)),    // Red
            ("16.67", (255, 142, 0)), // Orange
            ("33.33", (255, 239, 0)), // Yellow
            ("50.00", (0, 241, 29)),  // Green
            ("66.67", (0, 255, 255)), // Cyan
            ("83.33", (0, 64, 255)),  // Blue
            ("100.0", (128, 0, 255)), // Purple
        ];

        let sunset_gradient = [
            ("0.00", (255, 95, 109)),
            ("25.00", (255, 140, 105)),
            ("50.00", (255, 160, 122)),
            ("75.00", (255, 182, 193)),
            ("100.0", (255, 192, 203)),
        ];

        let ocean_gradient = [
            ("0.00", (30, 144, 255)),
            ("25.00", (0, 206, 209)),
            ("50.00", (32, 178, 170)),
            ("75.00", (72, 209, 204)),
            ("100.0", (0, 255, 255)),
        ];

        let gradient_data: &[(&str, (u8, u8, u8))] = match gradient_type {
            0 => &rainbow_gradient,
            1 => &sunset_gradient,
            2 => &ocean_gradient,
            _ => &rainbow_gradient,
        };

        writeln!(
            gradient,
            r#"<linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="0%">"#
        )
        .unwrap();
        for (offset, (r, g, b)) in gradient_data.iter() {
            writeln!(
                gradient,
                r#"<stop offset="{}%" stop-color="rgb({}, {}, {})"/>"#,
                offset, r, g, b
            )
            .unwrap();
        }
        writeln!(gradient, r#"</linearGradient>"#).unwrap();

        gradient
    }

    // Maps a single byte to a number between min and max
    fn map_byte(&self, byte: u8, min: usize, max: usize) -> i32 {
        (min + (byte as usize * (max - min) / 255)) as i32
    }
}

#[cfg(test)]
mod tests {
    use is_svg::is_svg;
    use std::{
        fs::{create_dir, File},
        io::Write,
        path::Path,
    };

    use super::*;

    #[test]
    fn test_svg_generation() {
        let seed = FixedBytes::<32>::random();
        let config = SquiggleGenerator::new(seed);
        let svg = config.svg();

        assert!(is_svg(svg));
    }

    #[test]
    fn test_output_100_svgs() {
        for i in 0..100 {
            let seed = FixedBytes::<32>::random();
            let config = SquiggleGenerator::new(seed);
            let svg = config.svg();
            assert!(is_svg(&svg));

            let dir = Path::new("test_output");
            if !dir.exists() {
                create_dir(dir).expect("Failed to create test output directory");
            }

            let file_name = format!("svg_{}.svg", i + 1);
            let file_path = Path::new(dir).join(file_name);
            let mut file = File::create(file_path).unwrap();
            file.write_all(svg.as_bytes()).unwrap();
        }
    }
}